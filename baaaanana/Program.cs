#define BUILD 
using Discord;
using Amonikano.Library;
using static Amonikano.Library.Helper;
using System;
using System.Collections.Generic; //Why collections when you can use array for more quality codes?
using System.Linq; //I hate Linq :(
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;
using Updater;

namespace Amonikano
{
    /// <summary>
    /// All of these constants are supposed to be kept secret, but whatever, we don't need secret do we?
    /// </summary>
    public static class bot_const
    {
        /// <summary>
        /// Gotten from website. Probably unique per application
        /// </summary>
        public const string client_id = "477149586851364867";
        public const string client_mention_id = "<@" + client_id + ">";

        /// <summary>
        /// Gotton from website. Probably unique per application
        /// </summary>
        public const string client_secret = "QC6QmXIgHG1LwW9XrqVs5cvXln4PeRPQ";
        /// <summary>
        /// Gotten from website. Impartant shit, grant 100% access to application
        /// </summary>
        public const string token = "NDc3MTQ5NTg2ODUxMzY0ODY3.Dk4JiA.6I0tIiF7WUvG_24OEEhAck996cI";
        /// <summary>
        /// devv/bot-test id
        /// </summary>
        public const ulong dev_channel_id = 477182725447483410;
    }

    public static class bot_conf
    {
#if COMPLETE
        #region command and user message distinguishment
        /// <summary>
        /// Set to true, and whether a command follows the syntax of a command or not, it would still be processed if mentioned.
        /// </summary>
        public const bool process_command_when_mentioned = true;
        /// <summary>
        /// Set to true and the bot will nullify all system messages generated by discord, or even itself
        /// </summary>
        public const bool nullify_system_message = true;

        public const bool check_prefix_determine_command = true;
        public const string str_command_prefix = "!";
        public const char char_command_prefix = '!';

        public const bool check_suffix_determine_command = false;
        public const string str_command_suffix = "«";
        public const char char_command_suffix = '«';

        public static bool is_command(Discord.WebSocket.SocketMessage msg)
        {
            //If msg is null, ignore it
            if (nullify_system_message)
            {
                Discord.WebSocket.SocketUserMessage user_msg = msg as Discord.WebSocket.SocketUserMessage;
                if (user_msg == null)
                    return false;
            }
            else
            {
                if (msg == null)
                    return false;
            }

            //set up processor (sorry if it's getting less and less readable)
        #region processor
            Dictionary<lookup_type, char[]> char_lookup = new Dictionary<lookup_type, char[]>();
            if (check_prefix_determine_command)
            {
                char_lookup[lookup_type.prefix] = new char[1] { char_command_prefix };
            }
            if (check_suffix_determine_command)
            {
                char_lookup[lookup_type.suffix] = new char[1] { char_command_suffix };
            }
            string content = msg.Content;
            custom_string_processor processor = new custom_string_processor(char_lookup, null, true);
        #endregion

            return processor.string_satisfied(content);
        }

        public const string startup_message = "Configs: \n " + (process_command_when_mentioned ? "+ process command if mentioned\n" : "")
            + (nullify_system_message ? "+ nullify system messages\n" : "")
            + (check_prefix_determine_command ? "+ command needs prefix: " + str_command_prefix + "\n" : "")
            + (check_suffix_determine_command ? "+ command needs suffix: " + str_command_suffix + "\n" : "")
            ;

        #endregion
        /// <summary>
        /// Socket configuration of a client
        /// </summary>
        public static Discord.WebSocket.DiscordSocketConfig socket_config = new Discord.WebSocket.DiscordSocketConfig
        {
            MessageCacheSize = 100, //Number of message per channel getting , idk?
            
        };
#else
        public const char char_prefix = '}';
        public const string str_prefix = "}";

        public const char mention_prefix = '@';
        public const string mention_prefix_str = "@";

        public static Discord.WebSocket.DiscordSocketConfig socket_config = new Discord.WebSocket.DiscordSocketConfig
        {
            MessageCacheSize = 100,

        };
        public const string startup_message = "Hello, Amonikano is on! Say something, and they'll respond.";
        public const string shutdown_message = "Amonikano is shutting down.";
        public static bool is_command(Discord.WebSocket.SocketMessage msg)
        {
            string msg_content = msg.Content;
            msg_content = msg_content.Trim();
            return msg_content[0] == char_prefix;
        }
        public static bool is_command(Discord.WebSocket.SocketMessage msg, out string new_string)
        {
            string msg_content = msg.Content;
            msg_content = msg_content.Trim();
            if (msg_content[0] == char_prefix)
            {
                new_string = msg_content.Substring(1);
                return true;
            }
            else
            {
                new_string = null;
                return false;
            }
        }
        public static bool is_command(string trimmed_msg)
        {
            return trimmed_msg[0] == char_prefix;
        }
        public static bool is_command(string trimmed_msg, out string new_string)
        {
            if (trimmed_msg[0] == char_prefix)
            {
                new_string = trimmed_msg.Substring(1);
                return true;
            }
            else
            {
                new_string = null;
                return false;
            }
        }
        public static bool is_command_raw(string untrimmed_msg)
        {
            untrimmed_msg = untrimmed_msg.Trim();
            return untrimmed_msg[0] == char_prefix;
        }
        public static bool is_command_raw(string untrimmed_msg, out string new_msg)
        {
            untrimmed_msg = untrimmed_msg.Trim();
            if (untrimmed_msg[0] == char_prefix)
            {
                new_msg = untrimmed_msg.Substring(1);
                return true;
            }
            else
            {
                new_msg = null;
                return false;
            }
        }

#endif

    }

    public static class program_const
    {
        // to get the location the assembly is executing from
     //(not necessarily where the it normally resides on disk)
     // in the case of the using shadow copies, for instance in NUnit tests, 
     // this will be in a temp directory.
        public static string path = System.Reflection.Assembly.GetExecutingAssembly().Location;

        //To get the location the assembly normally resides on disk or the install directory
        public static string path_code_base = System.Reflection.Assembly.GetExecutingAssembly().CodeBase;

        public static string updated_path = path +"/updated";

        public static string old_path = path + "/old_backup";

        /// <summary>
        /// The path where the execution is stored
        /// </summary>
        public static string[] execution_path
        {
            get
            {
                return new string[2] {
                    System.IO.Path.GetDirectoryName(path),
                    System.IO.Path.GetDirectoryName(path_code_base)
                };
            }
        }

    }


    class Program
    {
        public const string inv_webpage = "https://discordapp.com/oauth2/authorize?client_id=" + bot_const.client_id + "&scope=bot";
        public static Discord.WebSocket.DiscordSocketClient client;
        public static Discord.WebSocket.ISocketMessageChannel main_dev_channel = null;
        public static Discord.Commands.CommandService command_serv;
        IServiceProvider service;

        private async Task start()
        {
            main_dev_channel = (Discord.WebSocket.ISocketMessageChannel) client.GetChannel(bot_const.dev_channel_id);
            Console.WriteLine("main_dev_channel: " + main_dev_channel.Name);
            await ((IMessageChannel) main_dev_channel).SendMessageAsync(bot_conf.startup_message);
            Console.WriteLine("start() called");
        }

        static void Main(string[] args)
            => //This symbol is a lambda expression, search it up if you have to
            new Program().MainAsync(args).GetAwaiter().GetResult();
        

        /**
         * Basically, this calls an asynchronous main loop.
         * Because we assume the program run so fast that it runs asynchronously, there's nothing wrong with this.
        */
        /**
         * From here, I'll try to make the code looks neat and explanatory :)
         * */
        public async Task MainAsync(string[] args)
        {
#if BUILD
            SerializableUpdateInfo build_info = new SerializableUpdateInfo();
            build_info.Serialize(constants.path_here);
#else
            Updater.Program.start(args);
#endif
            //Initialize elements
            client = new Discord.WebSocket.
                DiscordSocketClient(bot_conf.socket_config);       
            command_serv = new Discord.Commands.CommandService();
            service = new ServiceCollection().BuildServiceProvider();

            //Delegates
            client.Log += on_client_log;
            client.MessageReceived += on_message_received;
            client.Ready += start;
#if TRACE
            Console.WriteLine("Path.Location = " + program_const.execution_path[0] + "\n" + "Path.CodeBase = " + program_const.execution_path[1] + "");
            //Console.WriteLine("main_dev_channel = " + main_dev_channel.Name);
#endif
            await load_commands();
            Amonikano.Library.AmonikanoCommands.CoreModule.InitializeHelpNoReply();
            await client.LoginAsync(TokenType.Bot, bot_const.token);
            Console.WriteLine("client.LoginAsync() called, awaiting client.StartAsync()");
            await client.StartAsync();
            Console.WriteLine("client.StartAsync() finished, awaiting Task.Delay(-1)");
            //AssignMainDevChannel();
            
            while (true)
            {
                string input;
                input = Console.ReadLine();
#if TRACE
                Console.WriteLine("Input was: " + input);
#endif
                //Command
                //Amonikano.Library.ConsoleCommands.GeneralExecution.ExecuteCommand(input.Split(' '));
                switch (input)
                {
                    case "inv_web":
                        Console.WriteLine(inv_webpage);
                        break;
                    case "force_shutdown":
                        goto shutdown;
                        
                }
            }
            shutdown:
            Console.WriteLine("main() ended");
            await main_dev_channel.SendMessageAsync(bot_conf.shutdown_message);
        }

        private static void AssignMainDevChannel()
        {
            while (client.ConnectionState != ConnectionState.Connected)
            {

            }
            Console.WriteLine("Assigning main_dev_channel");
            while (main_dev_channel == null)
            {
                Console.WriteLine("main_dev_channel is null, trying again");
                main_dev_channel = (Discord.WebSocket.ISocketMessageChannel)client.GetChannel(bot_const.dev_channel_id);
            }
            Console.WriteLine("main_dev_channel: " + main_dev_channel.Name);
        }

        #region Messaging
        /// <summary>
        /// Gets called whenever the client logs something
        /// This basically logs out on the bot console (not in discord, but prolly on my computer)
        /// </summary>
        /// <param name="msg"></param>
        /// <returns></returns>
        private async Task on_client_log(LogMessage msg) //not async because idk
        {
            Console.WriteLine(msg.ToString());
            await Task.CompletedTask;
        }

        private async Task load_commands()
        {
            await command_serv.AddModulesAsync(Assembly.GetEntryAssembly());
        }

        /// <summary>
        /// Gets called whenever the client receives a message from discord
        /// </summary>
        /// <param name="msg"></param>
        /// <returns></returns>
        private async Task on_message_received(Discord.WebSocket.SocketMessage msg)
        {
            string potential_command;
            bool is_command_by_mentioned = false;
            //TODO: make this work
            Console.WriteLine("=============== New Message ===============");
            string content = msg.Content;
            Discord.WebSocket.SocketUserMessage user_msg = msg as Discord.WebSocket.SocketUserMessage;
            Console.WriteLine("Content: " + content);
            Console.WriteLine("Is user message: " + (user_msg != null ? "true" : "false"));
            if (msg.Author.IsBot)
            {
                Console.WriteLine("Message is generated by a bot");
            }
            if (same_user(msg.Author, client.CurrentUser))
            {
                Console.WriteLine("Message generated by myself, aborting processing");
                return;
            }

            if (msg_mentioned_user(client.CurrentUser, user_msg, out potential_command))
            {
#if DEBUG
                await msg.Channel.SendMessageAsync("You mentioned me?");
#endif
                is_command_by_mentioned = true;
            }
            else
            {
                Console.WriteLine("Too bad, not mentioned :(.");
            }
            if (msg.Content == "#_THIS_CHANNEL_ID(\"-reply\")")
            {
                await msg.Channel.SendMessageAsync("This channel's ID is: " + msg.Channel.Id);
            }

#if DEBUG

            System.DateTime benchmark_start = DateTime.Now;
#endif
            if (is_command_by_mentioned || bot_conf.is_command_raw(content, out potential_command))
            {
                string output = "Detected input command of " + potential_command + ".";
#if DEBUG
                System.DateTime benchmark_end = DateTime.Now;
                TimeSpan delta = benchmark_end - benchmark_start;
                output += " " + delta.TotalMilliseconds.ToString() + "ms took to complete command detection algorithm.";
#endif
                await msg.Channel.SendMessageAsync(output);

                await ExecuteCommand(potential_command, user_msg);
            }
        }
        #endregion
        private async Task ExecuteCommand(string potential_command, Discord.WebSocket.SocketUserMessage user_msg)
        {
#if DEBUG
                DateTime start = DateTime.Now;
#endif
            //command
            Discord.Commands.CommandContext context = new Discord.Commands.CommandContext(client, user_msg);
            var result = await command_serv.ExecuteAsync(context, potential_command, service);
            if (!result.IsSuccess)
            {
                await context.Channel.SendMessageAsync(result.ErrorReason);
            }
#if DEBUG
                DateTime end = DateTime.Now;
                TimeSpan delta_time = end - start;
                await user_msg.Channel.SendMessageAsync("It took additionally " + delta_time.TotalMilliseconds.ToString() + " ms to execute command");
#endif
        }
    }
}
